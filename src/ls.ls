;; LispyScript - Javascript using tree syntax!
;; This is the compiler written in lispy itself.

(define _ (require "underscore"))
(define Module module.Constructor)

(define version "0.1.6")


(define macros {})


;; templates
(define templates {})
(set! templates.var (template (rest) "var " rest))
(set! templates.new (template (rest) "new " rest))
(set! templates.set (template (name value) name " = " value))
(set! templates.get (template (list key) list "[" key "]"))
(set! templates.operator (template (left operator right) left operator right))
(set! templates.str (template (rest) "[" rest "]"))
(set! templates.banner (template (version)
"// Generated by LispyScript v" version "\n"))
(set! templates.function (template (params expressions indent)
"function(" params ") {
" indent expressions "
}"))
(set! templates.try (template (try-expression catch-expression indent)
"(function() {
" indent "try {
" indent indent try-expression "
" indent "} catch (e) {
" indent indent "return (" catch-expression ")(e);
" indent "}"
"})()"))
(set! templates.if (template (condition true-exp false-exp)
condition " ?
" indent true-exp " :
" false-exp))


(define banner (templates.banner version))

;; utilities

(define repeat
  (lambda (string n)
    (var array (new Array (+ n 1)))
    (array.join string)))

(define rest
  (lambda (list) (Array.prototype.slice.call list 1)))

(define expression?
  (lambda (input) (array? input)))

;; keywords
(define keywords {})

(define operators
  (Array "+" "-" "*" "/" "%" "=" "!=" ">" ">=" "<" "<=" "||"))

(each operators
      (lambda (operator)
        (set! keywords[operator] handle-operator)))

(define operator-not "!")
(set! keywords[operator-not]
  (lambda (expression)
    (if (!= expression.length 2)
      (throw (handle-error
               0
               expression._line
               expression._filename)))

    ;; TODO: Improve operators support in order to allow
    ;; multi argument forms.
    (+ (+ "(!" (handle-sub-expressions expression)) ")")))

(set! keywords.var
      (lambda (expr)
        (if (< expr.length 2)
            (expr.push "undefined"))
        (templates.var (keywords.set expr))))

(set! keywords.new
      (lambda (expr)
        (if (< expr.length 2)
            (throw (handle-error 0 expr._line expr._filename)))

        (templates.new (handle-expression (rest 1)))))

(set! keywords.throw
      (lambda (expr)
        (if (< expr.length 2)
            (throw (handle-error 0 expr._line expr._filename)))

        (templates.throw (handle-expression (rest expr)))))

(set! keywords.get
      (lambda (expr)
        (if (!= expr.length 3)
            (throw (handle-error 0 expr._line expr._filename)))
        (templates.get expr[1] expr[2])))

(set! keywords.set
      (lambda (expr)
        (if (!= expr.length 3)
            (throw (handle-error 0 expr._line expr._filename)))
        (define name expr[1])
      (define value expr[2])
        (templates.set (handle-symbol name expr)
                      (if (expression? value)
                          (handle-expression value)
                          (handle-symbol value)))))

(set! keywords.function
      (lambda (expr)
        (if (< expr.length 3)
            (throw (handle-error 0 expr._line expr._filename)))

        (define params expr[1])
        (if (! (expression? params))
            (throw (handle-error 0 expr._line expr._filename)))

        (define param-symbols
          (map params (lambda (symbol) (handle-symbol symbol expr))))

        (templates.function
         (param-symbols.join ", ")
         (handle-expressions (rest (rest expr)))
         (repeat " " indent))))

(set! keywords.try
      (lambda (expression)
        (if (< expression.length 3)
          (throw (handle-error
                   0
                   expression._line
                   expression._filename)))

          (templates.try
            (handle-expressions (rest expression))
            (if (expression? catch-expression)
              (handle-expression catch-expression)
              (handle-symbol catch-expression))
            (repeat " " indent))

          (set! catch-expression (expression.pop))))

(set! keywords.if
      (lambda (expression)
        (if (|| (< expression.length 3)
                (> expression.length 4))
          (throw (handle-error
                   0
                   expression._line
                   expression._filename)))

        ;; TODO: pass indent-level rather than change globally
        (set! indent (+ indent 4))
        (set! expression (handle-sub-expressions expression))
        (define result
          (templates.if
            expression[1]
            expression[2]
            (|| expressions[3] "undefined")))

        (set! indent (- indent 4))
        result))

(set! keywords.str
  (lambda (expression)
    (if (< expression.length 2)
      (throw (handle-error
               0
               expression._line
               expression._filename)))

    (set! expression (handle-sub-expressions expression))
    (define input (rest expression))

    (templates.str (input.join ", "))))

(set! keywords.macro
  (lambda (expression)
    (if (!= expression.length 4)
      (throw (handle-error
               0
               expression._line
               expression._filename)))

    (define name expression[1])
    (define template expression[2])
    (define code expression[3])

    (set! macros[name] { template: expression[2], code: expression[3] })
    ""))

(set! keywords.include
  (lambda (expression)
    (if (!= expression.length 2)
      (throw (handle-error
             0
             expression._line
             expression._filename)))

    (set! indent (- indent 4))
    (define filename expression[1])
    (set! filename
      (if (string? filename)
        ;; Use two quotes in regexp or syntax highlighters go nuts.
        (filename.replace /"|'|"/g "")
        filename))

    (define module (new Module expression._filename))
    (set! module.filename expressions._filename)

    (try
      (require (Module._resolveFilename filename module))
      (lambda (error)
        (throw (handle-error
                 11
                 expression._line
                 expression._filename))))

    (set! indent (+ indent 4))
    ""))


;; predicates
(define predicate
  (lambda (regexp)
    (lambda (input) (regexp.test input))))

(define whitespace? (predicate /\s/))
(define function? (predicate /^function/))
(define validName? (predicate /^[a-zA-Z_$][0-9a-zA-Z_$]*$/))
(define no-return? (predicate /^var|set|throw\b/))


;; exports
(set! exports.version version)

