// Generated by LispyScript v0.2.1
var list = require("./list").list;
var isList = require("./list").isList;
var count = require("./list").count;
var isEmpty = require("./list").isEmpty;
var first = require("./list").first;
var second = require("./list").second;
var third = require("./list").third;
var rest = require("./list").rest;
var cons = require("./list").cons;
var rest = require("./list").rest;

var isOdd = require("./runtime").isOdd;
var dictionary = require("./runtime").dictionary;
var merge = require("./runtime").merge;
var keys = require("./runtime").keys;
var isNil = require("./runtime").isNil;
var rePattern = require("./runtime").rePattern;

var isSymbol = require("./ast").isSymbol;
var symbol = require("./ast").symbol;
var isKeyword = require("./ast").isKeyword;
var keyword = require("./ast").keyword;
var quote = require("./ast").quote;
var syntaxQuote = require("./ast").syntaxQuote;
var unquote = require("./ast").unquote;
var unquoteSplicing = require("./ast").unquoteSplicing;
var meta = require("./ast").meta;
var withMeta = require("./ast").withMeta;
var name = require("./ast").name;
var deref = require("./ast").deref;

var PushbackReader = function(source, uri, index, buffer) {
  this.source = source;
  this.uri = uri;
  this.indexAtom = index;
  this.bufferAtom = buffer;
  this.columnAtom = 1;
  this.lineAtom = 1;
  return this;
};

var pushBackReader = function(source, uri) {
  return new PushbackReader(source, uri, 0, "");
};

var line = function(reader) {
  return (reader).lineAtom;
};

var column = function(reader) {
  return (reader).columnAtom;
};

var nextChar = function(reader) {
  return isEmpty(reader.bufferAtom) ?
    reader.source[reader.indexAtom] :
    reader.bufferAtom[0];
};

var readChar = function(reader) {
  (nextChar(reader) === "\n") ?
    (function() {
      reader.lineAtom = (line(reader) + 1);
      return reader.columnAtom = 1;
    })() :
    reader.columnAtom = (column(reader) + 1);
  return isEmpty(reader.bufferAtom) ?
    (function() {
      var index = reader.indexAtom;
      reader.indexAtom = (index + 1);
      return reader.source[index];
    })() :
    (function() {
      var buffer = reader.bufferAtom;
      reader.bufferAtom = buffer.substr(1);
      return buffer[0];
    })();
};

var unreadChar = function(reader, ch) {
  return ch ?
    (function() {
      (ch === "\n") ?
        reader.lineAtom = (reader.lineAtom - 1) :
        reader.columnAtom = (reader.columnAtom - 1);
      return reader.bufferAtom = ''.concat(ch, reader.bufferAtom);
    })() :
    void 0;
};

var isBreakingWhitespace = function(ch) {
  return ("\t\n\r ".indexOf(ch) >= 0);
};

var isWhitespace = function(ch) {
  return (isBreakingWhitespace(ch) || ("," === ch));
};

var isNumeric = function(ch) {
  return ("01234567890".indexOf(ch) >= 0);
};

var isCommentPrefix = function(ch) {
  return (";" === ch);
};

var isNumberLiteral = function(reader, initch) {
  return (isNumeric(initch) || ((("+" === initch) || ("-" === initch)) && isNumeric(nextChar(reader))));
};

var readerError = function(reader, message) {
  return (function() {
    var error = Error(''.concat(message, "\n", "line:", line(reader), "\n", "column:", column(reader)));
    error.line = line(reader);
    error.column = column(reader);
    error.uri = reader["uri"];
    return (function() {
      throw error;
    })();
  })();
};

var isMacroTerminating = function(ch) {
  return (!(ch === "#") && (!(ch === "'") && (!(ch === ":") && macros(ch))));
};

var readToken = function(reader, initch) {
  return (function loop(buffer, ch) {
    var recur = loop;
    while ((recur === loop)) {
      recur = ((ch == null) || (isWhitespace(ch) || isMacroTerminating(ch))) ?
        (function() {
          unreadChar(reader, ch);
          return buffer;
        })() :
        (buffer = buffer.concat(ch),
         ch = readChar(reader),
         loop)
    };
    return recur;
  })(initch, readChar(reader));
};

var skipLine = function(reader, _) {
  return (function loop() {
    var recur = loop;
    while ((recur === loop)) {
      recur = (function() {
        var ch = readChar(reader);
        return ((ch === "\n") || ((ch === "\r") || (ch == null))) ?
          reader :
          loop;
      })()
    };
    return recur;
  })();
};

var intPattern = rePattern("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");

var ratioPattern = rePattern("([-+]?[0-9]+)/([0-9]+)");

var floatPattern = rePattern("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?");

var symbolPattern = rePattern("[:]?([^0-9/].*/)?([^0-9/][^/]*)");

var reFind = function(re, s) {
  return (function() {
    var matches = re.exec(s);
    return !(matches == null) ?
      (count(matches) == 1) ?
        matches[0] :
        matches :
      void 0;
  })();
};

var matchInt = function(s) {
  return (function() {
    var groups = reFind(intPattern, s);
    var group3 = groups[2];
    return !((group3 == null) || (count(group3) < 1)) ?
      0 :
      (function() {
        var negate = ("-" === groups[1]) ?
          -1 :
          1;
        var a = groups[3] ? ([ groups[3], 10 ]) :
        groups[4] ? ([ groups[4], 16 ]) :
        groups[5] ? ([ groups[5], 8 ]) :
        groups[7] ? ([ groups[7], parseInt(groups[7]) ]) :
        "default" ? ([ nil, nil ]) :
        void 0;
        var n = a[0];
        var radix = a[1];
        return (n == null) ?
          nil :
          (negate * parseInt(n, radix));
      })();
  })();
};

var matchRatio = function(s) {
  return (function() {
    var groups = reFind(ratioPattern, s);
    var numinator = groups[1];
    var denominator = groups[2];
    return (parseInt(numinator) / parseInt(denominator));
  })();
};

var matchFloat = function(s) {
  return parseFloat(s);
};

var reMatches = function(pattern, source) {
  return (function() {
    var matches = pattern.exec(source);
    return (!(matches == null) && (matches[0] === source)) ?
      (function() {
        return (count(matches) == 1) ?
          matches[0] :
          matches;
      })() :
      void 0;
  })();
};

var matchNumber = function(s) {
  return reMatches(intPattern, s) ? (matchInt(s)) :
  reMatches(ratioPattern, s) ? (matchRatio(s)) :
  reMatches(floatPattern, s) ? (matchFloat(s)) :
  void 0;
};

var escapeCharMap = function(c) {
  return (c === "t") ? ("\t") :
  (c === "r") ? ("\r") :
  (c === "n") ? ("\n") :
  (c === "\\") ? ("\\") :
  (c === "\"") ? ("\"") :
  (c === "b") ? ("\b") :
  (c === "f") ? ("\f") :
  "else" ? (nil) :
  void 0;
};

var read2Chars = function(reader) {
  return ''.concat(readChar(reader), readChar(reader));
};

var read4Chars = function(reader) {
  return ''.concat(readChar(reader), readChar(reader), readChar(reader), readChar(reader));
};

var unicode2Pattern = rePattern("[0-9A-Fa-f]{2}");

var unicode4Pattern = rePattern("[0-9A-Fa-f]{4}");

var validateUnicodeEscape = function(unicodePattern, reader, escapeChar, unicodeStr) {
  return reMatches(unicodePattern, unicodeStr) ?
    unicodeStr :
    readerError(reader, ''.concat("Unexpected unicode escape ", "\\", escapeChar, unicodeStr));
};

var makeUnicodeChar = function(codeStr) {
  return (function() {
    var code = parseInt(codeStr, 16);
    return String.fromCharCode(code);
  })();
};

var escapeChar = function(buffer, reader) {
  return (function() {
    var ch = readChar(reader);
    var mapresult = escapeCharMap(ch);
    return mapresult ?
      mapresult :
      (ch === "x") ? (makeUnicodeChar(validateUnicodeEscape(unicode2Pattern, reader, ch, read2Chars(reader)))) :
      (ch === "u") ? (makeUnicodeChar(validateUnicodeEscape(unicode4Pattern, reader, ch, read4Chars(reader)))) :
      isNumeric(ch) ? (String.fromCharCode(ch)) :
      "else" ? (readerError(reader, ''.concat("Unexpected unicode escape ", "\\", ch))) :
      void 0;
  })();
};

var readPast = function(predicate, reader) {
  return (function loop(ch) {
    var recur = loop;
    while ((recur === loop)) {
      recur = predicate(ch) ?
        (ch = readChar(reader),
         loop) :
        ch
    };
    return recur;
  })(readChar(reader));
};

var readDelimitedList = function(delim, reader, isRecursive) {
  return (function loop(a) {
    var recur = loop;
    while ((recur === loop)) {
      recur = (function() {
        var ch = readPast(isWhitespace, reader);
        !ch ?
          readerError(reader, "EOF") :
          void 0;
        return (delim === ch) ?
          a :
          (function() {
            var macrofn = macros(ch);
            return macrofn ?
              (function() {
                var mret = macrofn(reader, ch);
                return (a = (mret === reader) ?
                  a :
                  a.concat([ mret ]),
                 loop);
              })() :
              (function() {
                unreadChar(reader, ch);
                return (function() {
                  var o = read(reader, true, nil, isRecursive);
                  return (a = (o === reader) ?
                    a :
                    a.concat([ o ]),
                   loop);
                })();
              })();
          })();
      })()
    };
    return recur;
  })([]);
};

var notImplemented = function(reader, ch) {
  return readerError(reader, ''.concat("Reader for ", ch, " not implemented yet"));
};

var readDispatch = function(reader, _) {
  return (function() {
    var ch = readChar(reader);
    var dm = dispatchMacros(ch);
    return dm ?
      dm(reader, _) :
      (function() {
        var object = maybeReadTaggedType(reader, ch);
        return object ?
          object :
          readerError(reader, "No dispatch macro for ", ch);
      })();
  })();
};

var readUnmatchedDelimiter = function(rdr, ch) {
  return readerError(rdr, "Unmached delimiter ", ch);
};

var readList = function(reader) {
  return list.apply(list, readDelimitedList(")", reader, true));
};

var readComment = skipLine;

var readVector = function(reader) {
  return readDelimitedList("]", reader, true);
};

var readMap = function(reader) {
  return (function() {
    var items = readDelimitedList("}", reader, true);
    isOdd((items).length) ?
      readerError(reader, "Map literal must contain an even number of forms") :
      void 0;
    return dictionary.apply(dictionary, items);
  })();
};

var readNumber = function(reader, initch) {
  return (function loop(buffer, ch) {
    var recur = loop;
    while ((recur === loop)) {
      recur = ((ch == null) || (isWhitespace(ch) || macros(ch))) ?
        (function() {
          unreadChar(reader, ch);
          var match = matchNumber(buffer);
          return (match == null) ?
            readerError(reader, "Invalid number format [", buffer, "]") :
            match;
        })() :
        (buffer = ''.concat(buffer, ch),
         ch = readChar(reader),
         loop)
    };
    return recur;
  })(initch, readChar(reader));
};

var readString = function(reader) {
  return (function loop(buffer, ch) {
    var recur = loop;
    while ((recur === loop)) {
      recur = (ch == null) ? (readerError(reader, "EOF while reading string")) :
      ("\\" === ch) ? ((buffer = ''.concat(buffer, escapeChar(buffer, reader)),
       ch = readChar(reader),
       loop)) :
      ("\"" === ch) ? (buffer) :
      "default" ? ((buffer = ''.concat(buffer, ch),
       ch = readChar(reader),
       loop)) :
      void 0
    };
    return recur;
  })("", readChar(reader));
};

var readUnquote = function(reader) {
  return (function() {
    var ch = readChar(reader);
    return !ch ?
      readerError(reader, "EOF while reading character") :
      (ch === "@") ?
        list(unquoteSplicing, read(reader, true, nil, true)) :
        (function() {
          unreadChar(reader, ch);
          return list(unquote, read(reader, true, nil, true));
        })();
  })();
};

var specialSymbols = function(text, notFound) {
  return (text === "nil") ? (nil) :
  (text === "true") ? (true) :
  (text === "false") ? (false) :
  "else" ? (notFound) :
  void 0;
};

var readSymbol = function(reader, initch) {
  return (function() {
    var token = readToken(reader, initch);
    return (token.indexOf("/") >= 0) ?
      symbol(token.substr(0, token.indexOf("/")), token.substr((token.indexOf("/") + 1), (token).length)) :
      specialSymbols(token, symbol(token));
  })();
};

var readKeyword = function(reader, initch) {
  return (function() {
    var token = readToken(reader, readChar(reader));
    var a = reMatches(symbolPattern, token);
    var token = a[0];
    var ns = a[1];
    var name = a[2];
    return ((!(ns === undefined) && (ns.substring(((ns).length - 2), (ns).length) === ":/")) || ((name[((name).length - 1)] === ":") || !(token.indexOf("::", 1) == -1))) ?
      readerError(reader, "Invalid token: ", token) :
      (!(ns == null) && ((ns).length > 0)) ?
        keyword(ns.substring(0, ns.indexOf("/")), name) :
        keyword(token);
  })();
};

var desugarMeta = function(f) {
  return isSymbol(f) ? (dictionary(keyword("tag"), f)) :
  (Object.prototype.toString.call(f) === '[object String]') ? (dictionary(keyword("tag"), f)) :
  isKeyword(f) ? (dictionary(f, true)) :
  "else" ? (f) :
  void 0;
};

var wrappingReader = function(prefix) {
  return function(reader) {
    return list(prefix, read(reader, true, nil, true));
  };
};

var throwingReader = function(msg) {
  return function(reader) {
    return readerError(reader, msg);
  };
};

var readMeta = function(reader, _) {
  return (function() {
    var m = desugarMeta(read(reader, true, nil, true));
    !(m && (typeof(m) === "object")) ?
      readerError(reader, "Metadata must be Symbol, Keyword, String or Map") :
      void 0;
    return (function() {
      var o = read(reader, true, nil, true);
      return (o && (typeof(o) === "object")) ?
        withMeta(o, merge(meta(o), m)) :
        o;
    })();
  })();
};

var readSet = function(reader, _) {
  return list.apply(list, [ symbol("set") ].concat(readDelimitedList("}", reader, true)));
};

var readRegex = function(reader) {
  return (function loop(buffer, ch) {
    var recur = loop;
    while ((recur === loop)) {
      recur = (ch == null) ? (readerError(reader, "EOF while reading string")) :
      ("\\" === ch) ? ((buffer = ''.concat(buffer, ch, readChar(reader)),
       ch = readChar(reader),
       loop)) :
      ("\"" === ch) ? (rePattern(buffer.split("/").join("\\/"))) :
      "default" ? ((buffer = ''.concat(buffer, ch),
       ch = readChar(reader),
       loop)) :
      void 0
    };
    return recur;
  })("", readChar(reader));
};

var readDiscard = function(reader, _) {
  read(reader, true, nil, true);
  return reader;
};

var macros = function(c) {
  return (c === "\"") ? (readString) :
  (c === ":") ? (readKeyword) :
  (c === ";") ? (readComment) :
  (c === "'") ? (wrappingReader(quote)) :
  (c === "@") ? (wrappingReader(deref)) :
  (c === "^") ? (readMeta) :
  (c === "`") ? (wrappingReader(syntaxQuote)) :
  (c === "~") ? (readUnquote) :
  (c === "(") ? (readList) :
  (c === ")") ? (readUnmatchedDelimiter) :
  (c === "[") ? (readVector) :
  (c === "]") ? (readUnmatchedDelimiter) :
  (c === "{") ? (readMap) :
  (c === "}") ? (readUnmatchedDelimiter) :
  (c === "\\") ? (readChar) :
  (c === "%") ? (notImplemented) :
  (c === "#") ? (readDispatch) :
  "else" ? (nil) :
  void 0;
};

var dispatchMacros = function(s) {
  return (s === "{") ? (readSet) :
  (s === "<") ? (throwingReader("Unreadable form")) :
  (s === "\"") ? (readRegex) :
  (s === "!") ? (readComment) :
  (s === "_") ? (readDiscard) :
  "else" ? (nil) :
  void 0;
};

var read = function(reader, eofIsError, sentinel, isRecursive) {
  return (function loop() {
    var recur = loop;
    while ((recur === loop)) {
      recur = (function() {
        var ch = readChar(reader);
        return (ch == null) ? (eofIsError ?
          readerError(reader, "EOF") :
          sentinel) :
        isWhitespace(ch) ? (loop) :
        isCommentPrefix(ch) ? (read(readComment(reader, ch), eofIsError, sentinel, isRecursive)) :
        "else" ? ((function() {
          var f = macros(ch);
          var res = f ? (f(reader, ch)) :
          isNumberLiteral(reader, ch) ? (readNumber(reader, ch)) :
          "else" ? (readSymbol(reader, ch)) :
          void 0;
          return (res === reader) ?
            loop :
            res;
        })()) :
        void 0;
      })()
    };
    return recur;
  })();
};

var readFromString = function(source, uri) {
  return (function() {
    var reader = pushBackReader(source, uri);
    return read(reader, true, nil, false);
  })();
};

var readUuid = function(uuid) {
  return (Object.prototype.toString.call(uuid) === '[object String]') ?
    list(symbol("new"), symbol("UUID"), uuid) :
    readerError(nil, "UUID literal expects a string as its representation.");
};

var readQueue = function(items) {
  return (Object.prototype.toString.call(items) === '[object Array]') ?
    list(symbol("new"), symbol("PersistentQueue"), items) :
    readerError(nil, "Queue literal expects a vector for its elements.");
};

var __tagTable__ = dictionary("uuid", readUuid, "queue", readQueue);

var maybeReadTaggedType = function(reader, initch) {
  return (function() {
    var tag = readSymbol(reader, initch);
    var pfn = __tagTable__[name(tag)];
    return pfn ?
      pfn(read(reader, true, nil, false)) :
      readerError(reader, ''.concat("Could not find tag parser for ", name(tag), " in ", ''.concat(keys(__tagTable__))));
  })();
};

exports.read = read;
exports.readFromString = readFromString;

