/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/
define(function(require, exports, module) {

var _ = require('underscore');
var Module = module.constructor;

String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
};

exports.version = "0.2.0";
var _LS = {},
    banner = "// Generated by LispyScript v" + this.version + "\n",
    isWhitespace = /\s|\,/,
    isFunction = /^function/,
    validSymbol = /^[a-zA-Z_$]([\-\.\[]{0,1}[0-9a-zA-Z_$]+\]{0,1})*\?{0,1}$/,
    validName = /[a-zA-Z_$]/,
    noReturn = /^var|set|throw\b/,
    indent = -4,
    keywords = {},
    macros = {},
    templates = {};
templates["str"] = _.template("[<%= elems %>].join('')");
templates[".invoke"] = _.template("(<%= target %>).<%= method %>");
templates[".field"] = _.template("(<%= target %>).<%= field %>");
templates["loop"] = _.template("(function loop(<%= names %>) {\n  var recur = loop;\n  while (recur === loop) {\n    recur = <%= body %>\n  }\n  return recur;\n})(<%= values %>)");

var parse = function(code, filename) {
    code = "(" + code + ")";
    var length = code.length,
        pos = 1,
        lineno = 1;

    var parser = function() {
        var tree = [],
            token = "",
            special = "",
            isString = false,
            isSingleString = false,
            isJSObject = 0,
            isListComplete = false,
            isComment = false,
            isRegex = false;
        tree._line = lineno;
        tree._filename = filename;
        var handleToken = function() {
            if (token) {
                if (special) {
                    tree.push([ special, token ]);
                    special = "";
                }
                else
                    tree.push(token);
                token = "";
            }
        };
        while (pos < length) {
            var c = code.charAt(pos);
            pos++;
            if (c == "\n") {
                lineno++;
                if (isComment) isComment = false;
            }
            if (isComment) continue;
            if (c == '"') {
                if (isString && token[token.length - 1] === "\\") {
                    token += c;
                    continue;
                }
                isString = !isString;
                token += c;
                continue;
            }
            if (isString) {
                if (c === "\n")
                    token += "\\n";
                else
                    token += c;
                continue;
            }
            if (isSingleString) {
                token += c;
                continue;
            }
            if (c == '{') {
                isJSObject++;
                token += c;
                continue;
            }
            if (c == '}') {
                if (isJSObject === 0) throw handleError(6, tree._line, tree._filename);
                isJSObject--;
                token += c;
                continue;
            }
            if (isJSObject) {
                token += c;
                continue;
            }
            if (c == ";") {
                isComment = true;
                continue;
            }

            if (c == "(" || c == "[") {
                var compound = parser();
                if (special) {
                    tree.push([ special, compound ]);
                    special = "";
                }
                else
                    tree.push(compound);
                continue;
            }
            if (c == ")" || c == "]") {
                isListComplete = true;
                handleToken();
                break;
            }
            if (isWhitespace.test(c)) {
                handleToken();
                continue;
            }
            if (c === "`") {
              special = "quasiquote";
              continue;
            }
            if (c === "'") {
              special = "quote";
              continue;
            }
            if (c === "~") {
              special = "unquote";
              continue;
            }
            if (c === "#") {
              special = "dispatch*";
              continue;
            }
            token += c;
        }
        if (isString) throw handleError(3, tree._line, tree._filename);
        if (isSingleString) throw handleError(3, tree._line, tree._filename);
        if (isJSObject > 0) throw handleError(7, tree._line, tree._filename);
        if (!isListComplete) throw handleError(8, tree._line, tree._filename);
        return tree;
    };
    var ret = parser();
    if (pos < length) throw handleError(10);
    return ret;
};

function next(form) {
  var result = form.slice(1);
  result._line = form._line;
  result._filename = form._filename;
  return result;
}
var rest = next;

function first(form) {
  return form[0];
}

var handleExpressions = function(exprs) {
    indent += 4;
    var ret = "",
        l = exprs.length,
        indentstr = " ".repeat(indent);
    _.each(exprs, function(expr, i, exprs) {
        var tmp = "", r = "";
        if (_.isArray(expr)) {
            if (expr[0] === "include")
                ret += handleExpression(expr);
            if (expr[0][0] === "^")
                return;
            else
                tmp = handleExpression(expr);
        } else {
            tmp = expr;
        }
        if (i === l - 1 && indent) {
            if (!noReturn.test(tmp)) r = "return ";
        }
        if (tmp.length > 0)
            ret += indentstr + r + tmp + ";\n\n";
    });
    indent -= 4;
    return ret;
};


var handleSymbol = function(symbol, expr) {
  if (!validName.test(symbol.charAt(0)))
    return symbol;
  if (!validSymbol.test(symbol))
      throw handleError(12, expr._line, expr._filename);

    return symbol.split('.').map(function(name) {
      var isPredicate = name.substr(-1) === "?";
      name = isPredicate ? name.substr(0, name.length - 1) : name;
      return name.split('-').reduce(function(result, $) {
        return result + (result ? $[0].toUpperCase() + $.substr(1) : $);
      }, isPredicate ? 'is' : '');
    }).join('.');
};

var handleExpression = function(expr) {
    if (!_.isArray(expr))
      return handleSymbol(expr);

    var command = expr[0];
    var filename = expr._filename;
    var line = expr._line;
    // Remove metadata expressions as we can't handle them just yet.
    expr = expr.filter(function(symbol) {
      return symbol[0] !== "^";
    }).
    // If symbol is if a character type \+ we replace it with
    // equivalent string.
    map(function(symbol) {
      return symbol[0] === "\\" && symbol.length === 2 ? "\"" + symbol + "\""
                                                       : symbol;
    }).
    // If symbol is a keyword :foo than swap it with js equivalent
    map(function(symbol) {
      return symbol[0] === ":" ? "\"" + symbol.substr(1) + "\"" : symbol;
   });
    expr._filename = filename;
    expr._line = line;

    if (macros.hasOwnProperty(command)) {
        return handleExpression(macroExpand(expr));
    }
    if (_.isString(command)) {
        if (keywords.hasOwnProperty(command))
            return keywords[command](expr);

        for (var prefix in readers) {
          if (command.indexOf(prefix) === 0)
            return readers[prefix](expr);
        }
    }
    handleSubExpressions(expr);
    var fName = expr[0];
    if (!fName) throw handleError(1, expr._line);
    if (isFunction.test(fName)) fName = "(" + fName + ")";
    return fName + "(" + rest(expr).join(", ") + ")";
};

var handleSubExpressions = function(expr) {
    _.each(expr, function(value, i, t) {
      t[i] = _.isArray(value) ? handleExpression(value)
                              : handleSymbol(value);
    });
    return expr;
};

function findMacro(name) {
}

var macroExpand = function(form) {
  var name = first(form);
  return macros[name](next(form));
};

var handleError = function(no, line, filename) {
    return errors[no] + ((line) ? "\nLine no " + line : "") + ((filename) ? "\nFile " + filename : "");
};

var readers = {};

readers[".-"] = function(expression) {
  var invoker = expression[0];
  var target = expression[1];
  var owner = _.isArray(target) ? handleExpression(target)
                                : handleSymbol(target);
  var field = handleSymbol(invoker.substr(2));
  return templates[".field"]({ target: owner, field: field });

};

readers["."] = function(expression) {
  var invoker = expression[0].substr(1);
  var params = expression.slice(2);

  expression.unshift('invoke-method*');
  expression[1] = invoker;
  handleExpression(expression);

  return handleExpression(expression);
};


keywords["js*"] = function(form) {
  var template = form[1].replace(/\\n/g, '\n');
  var values = handleSubExpressions(form.slice(2));
  var result = template.replace(/(\n\ *)*(\~\{\})/g, function(match, p1, p2) {
    var indent = p1 || '';
    return indent + values.shift().split('\n').join('\n' + indent.split('\n').join(''));
  });
  // strip out additional quotes.
  return result.substr(1, result.length - 2);
};

keywords["symbol"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    return arr[1].substr(1, arr[1].length - 2)
}

keywords["symbols-join"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    return handleSubExpressions(arr.slice(2)).join(handleExpression(arr[1]));
};

keywords["str"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    handleSubExpressions(arr);
    return templates["str"]({elems: arr.slice(1).join(",")});
};

function expandRecur(form, names) {
  return form.map(function(form) {
    if (!_.isArray(form))
      return form;
    else if (form && form[0] === 'recur') {
      var expressions = form.slice(1).map(function(expression, index) {
        return [ 'set!', names[index], expression ];
      });
      return [ 'grouped-statements*' ].concat(expressions).concat('loop');
    } else
      return expandRecur(form, names);
  });
}

function isEven(_, x) { return !!(x % 2); }
function isOdd(_, x) { return !(x % 2); }

keywords.loop = function(form) {
  if (form.length < 2) throw handleError(0, form._line, form._filename);
  var bindings = form[1];
  var names = bindings.filter(isOdd);
  var values = bindings.filter(isEven);
  var body = form.slice(2);

  return handleExpression([ 'loop*', names, values, expandRecur(body, names) ]);
};

function isString(form) {
  /**
  True if it's a string form.
  **/
  return typeof form === "string" &&
         form[0] === "\"" &&
         form[form.length - 1] === "\"";
}

keywords["defmacro"] = function defmacro(form) {
    // If macro definition contains doc string remove it.
    if (isString(form[2])) form.splice(2, 1);
    if (form.length < 3) throw handleError(0, form._line, form._filename);
    var name = form[1];
    if (!_.isArray(form[2][0]))
      return defmacro([ "defmacro", name, form.slice(2) ]);
    else
      macros[name] = Macro(form.slice(2));

    return "";
};

function record() {
  var names = Array.prototype.slice.call(arguments);
  return function Record() {
    var values = Array.prototype.slice.call(arguments);
    return names.reduce(function(result, name) {
      result[name] = value[name];
    }, {});
  };
}

var macroPattern = function(descriptor) {
  return { params: descriptor[0], rules: descriptor[1] };
};
var isMacroPatternVariadic = function(pattern) {
  return pattern.params.indexOf("&") >= 0;
};
var complement = function(predicate) {
  return _.compose(function(value) { return !value; }, predicate);
};

function expand(rules, env, form) {
  var result = [];

  for (var i = 0; i < rules.length; i++) {
    var symbol = rules[i];
    if (_.isArray(symbol)) {
      if (symbol[0] === "unquote" ||
          symbol[0] === "quote" ||
          symbol[0] === "quasiquote")
          result = result.concat(expand(symbol, env, form));
      else
          result.push(expand(symbol, env, form));
    }
    else if (symbol === "unquote") {
      symbol = rules[++i];
      if (_.isArray(symbol)) {
        result.push(expand(symbol, env, form));
      } else  {
        var splicing = symbol[0] === "@";
        var name = splicing ? symbol.substr(1) : symbol;
        var value = env[name];
        if (splicing)
          result = result.concat(value);
        else
          result.push(value);
      }
    } else if (symbol === "quote") {
      result.push(rules[++i]);
    } else if (symbol === "quasiquote") {
      result = result.concat(expand(rules[++i], env, form));
    }
    else {
      result.push(symbol);
    }
  }

  result._line = form._line;
  result._filename = form._filename;
  return result;
}

function Macro(descriptors) {
  var patterns = descriptors.map(macroPattern);
  // Store patterns accepting variadic number params into
  // array sorted by non-variadic params count. From bigger
  // to smaller. That way best match will be the first one
  // with a less params defined than provided.
  var variadic = patterns.filter(isMacroPatternVariadic)
                         .sort(function(a, b) {
                            return b.params.length - a.params.length;
                          });

  // Store fixed param length patterns in a map indexed by params expected.
  var fixed = patterns.filter(complement(isMacroPatternVariadic))
                      .reduce(function(map, pattern) {
                        map[pattern.params.length] = pattern;
                        return map;
                      }, {});

  // Create a macro function that takes `form` as input and returns
  // expanded form as output.
  return function macro(form) {
    var length = form.length;
    // If pattern with matching fixed argument length is defined use it.
    // Otherwise find a best match from the variadic patterns (one with
    // more fixed params is considered best). Note as we stored variadic
    // patterns in order of the params they define first one that can
    // handle as many params is the best match.
    var pattern = fixed[form.length] || _.find(variadic, function(pattern) {
      return pattern.params.length - 2 < length;
    });

    if (!pattern) throw handleError(13, form._line, form._filename);

    // create environment object that maps param names to a given `form`.
    var env = pattern.params.reduce(function(result, name, index) {
      if (name === "&") {
        result[name] = form.slice(index);
      } else if (result["&"]) {
        result[name] = result["&"];
      } else {
        result[name] = form[index];
      }
      return result;
    }, {});

    // Expand macro rules.
    return expand(pattern.rules, env, form);
  };
}

keywords["include"] = function(arr) {
    if (arr.length != 2)  throw handleError(0, arr._line, arr._filename);
    indent -= 4;
    var filename = arr[1];
    if (typeof filename === "string")
        filename = filename.replace(/["']/g, "");

    var module = new Module(arr._filename);
    module.filename = arr._filename;

    try {
        filename = Module._resolveFilename(filename, module);
        require(filename);
    } catch (err) {
        throw handleError(11, arr._line, arr._filename);
    }

    indent += 4;
    return "";
};

errors = [];
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid variable name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";
errors[11] = "Cannot Open include File";
errors[12] = "Invalid symbol";
errors[13] = "Macro does not supports given form (number of symbols is invalid)";

exports._compile = function(code, filename) {
  indent = -4;
  var tree = parse(code, filename);
  return banner + handleExpressions(tree);
};

});
