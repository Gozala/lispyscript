/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/
define(function(require, exports, module) {

var _ = require('underscore');
var Module = module.constructor;

String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
};

exports.version = "0.1.6";
var _LS = {},
    banner = "// Generated by LispyScript v" + this.version + "\n",
    isWhitespace = /\s/,
    isFunction = /^function/,
    validSymbol = /^[a-zA-Z_$]([\-\.\[]{0,1}[0-9a-zA-Z_$]+\]{0,1})*\?{0,1}$/,
    validName = /[a-zA-Z_$]/,
    noReturn = /^var|set|throw\b/,
    indent = -4,
    keywords = {},
    macros = {},
    templates = {};
templates["function"] = _.template("function(<%= params %>) {\n<%= expressions %><%= indent %>}");
templates["try"] = _.template("(function () {\n<%= indent %><%= indent %>try {\n<%= indent %><%= trypart %>\n<%= indent %><%= indent %>} catch (e) {\n<%= indent %><%= indent %><%= indent %>return (<%= catchpart %>)(e);\n<%= indent %><%= indent %>}\n<%= indent %>})()");
templates["if"] = _.template("<%= condition %> ?\n<%= indent %><%= trueexpr %> :\n<%= indent %><%= falseexpr %>");
templates["operator"] = _.template("(<%= loperand %> <%= operator %> <%= roperand %>)");
templates["str"] = _.template("[<%= elems %>].join('')");
templates[".invoke"] = _.template("(<%= target %>).<%= method %>");
templates[".field"] = _.template("(<%= target %>).<%= field %>");

var parse = function(code, filename) {
    code = "(" + code + ")";
    var length = code.length,
        pos = 1,
        lineno = 1;

    var parser = function() {
        var tree = [],
            token = "",
            special = "",
            isString = false,
            isSingleString = false,
            isJSArray = 0,
            isJSObject = 0,
            isListComplete = false,
            isComment = false,
            isRegex = false;
        tree._line = lineno;
        tree._filename = filename;
        var handleToken = function() {
            if (token) {
                if (special) {
                    tree.push([ special, token ]);
                    special = "";
                }
                else
                    tree.push(token);
                token = "";
            }
        };
        while (pos < length) {
            var c = code.charAt(pos);
            pos++;
            if (c == "\n") {
                lineno++;
                if (isComment) isComment = false;
            }
            if (isComment) continue;
            if (isRegex && c !== "/") {
                token += c;
                continue;
            }
            if (c == '"') {
                if (isString && token[token.length - 1] === "\\") {
                    token += c;
                    continue;
                }
                isString = !isString;
                token += c;
                continue;
            }
            if (isString) {
                if (c === "\n")
                    token += "\\n";
                else
                    token += c;
                continue;
            }
            if (isSingleString) {
                token += c;
                continue;
            }
            if (c == '[') {
                isJSArray++;
                token += c;
                continue;
            }
            if (c == ']') {
                if (isJSArray === 0) throw handleError(4, tree._line, tree._filename);
                isJSArray--;
                token += c;
                continue;
            }
            if (isJSArray) {
                token += c;
                continue;
            }
            if (c == '{') {
                isJSObject++;
                token += c;
                continue;
            }
            if (c == '}') {
                if (isJSObject === 0) throw handleError(6, tree._line, tree._filename);
                isJSObject--;
                token += c;
                continue;
            }
            if (isJSObject) {
                token += c;
                continue;
            }
            if (c == ";") {
                isComment = true;
                continue;
            }

            if (c == '/') {
                if (isRegex && token[token.length - 1] === "\\") {
                    token += c;
                    continue;
                }
                isRegex = !isRegex;
                token += c;
                continue;
            }


            if (c == "(") {
                var compound = parser();
                if (special) {
                    tree.push([ special, compound ]);
                    special = "";
                }
                else
                    tree.push(compound);
                continue;
            }
            if (c == ")") {
                isListComplete = true;
                handleToken();
                break;
            }
            if (isWhitespace.test(c)) {
                handleToken();
                continue;
            }
            if (c === "`") {
              special = "quasiquote";
              continue;
            }
            if (c === "'") {
              special = "quote";
              continue;
            }
            if (c === "~") {
              special = "unquote";
              continue;
            }
            token += c;
        }
        if (isString) throw handleError(3, tree._line, tree._filename);
        if (isSingleString) throw handleError(3, tree._line, tree._filename);
        if (isJSArray > 0) throw handleError(5, tree._line, tree._filename);
        if (isJSObject > 0) throw handleError(7, tree._line, tree._filename);
        if (!isListComplete) throw handleError(8, tree._line, tree._filename);
        return tree;
    };
    var ret = parser();
    if (pos < length) throw handleError(10);
    return ret;
};

var handleExpressions = function(exprs) {
    indent += 4;
    var ret = "",
        l = exprs.length,
        indentstr = " ".repeat(indent);
    _.each(exprs, function(expr, i, exprs) {
        var tmp = "", r = "";
        if (_.isArray(expr)) {
            if (expr[0] === "include")
                ret += handleExpression(expr);
            else
                tmp = handleExpression(expr);
        } else {
            tmp = expr;
        }
        if (i === l - 1 && indent) {
            if (!noReturn.test(tmp)) r = "return ";
        }
        if (tmp.length > 0)
            ret += indentstr + r + tmp + ";\n";
    });
    indent -= 4;
    return ret;
};

var handleSymbol = function(symbol, expr) {
  if (!validName.test(symbol.charAt(0)))
    return symbol;
  if (!validSymbol.test(symbol))
      throw handleError(12, expr._line, expr._filename);
    var isPredicate = symbol.substr(-1) === "?";
    var name = isPredicate ? symbol.substr(0, symbol.length - 1) : symbol;

    return name.split('-').reduce(function(result, $) {
      return result + (result ? $[0].toUpperCase() + $.substr(1) : $);
    }, isPredicate ? 'is' : '');
};

var handleExpression = function(expr) {
    var command = expr[0];
    if (macros[command]) {
        expr = macroExpand(expr);
        return handleExpression(expr);
    }
    if (_.isString(command)) {
        if (keywords[command])
            return keywords[command](expr);

        for (var prefix in readers) {
          if (command.indexOf(prefix) === 0)
            return readers[prefix](expr);
        }
    }
    handleSubExpressions(expr);
    var fName = expr[0];
    if (!fName) throw handleError(1, expr._line);
    if (isFunction.test(fName)) fName = "(" + fName + ")";
    return fName + "(" + expr.slice(1).join(",") + ")";
};

var handleSubExpressions = function(expr) {
    _.each(expr, function(value, i, t) {
      t[i] = _.isArray(value) ? handleExpression(value)
                              : handleSymbol(value);
    });
    return expr;
};

var macroExpand = function(tree) {
    var command = tree[0],
        template = macros[command].template,
        code = macros[command].code,
        replacements = {};

    for (var i = 0; i < template.length; i++) {
        if (template[i].substr(-3) === "...") {
            replacements[template[i]] = tree.slice(i + 1);
        } else {
            replacements[template[i]] = tree[i + 1];
        }
    }

    var replaceCode = function(source) {
        var ret = [];
        ret._line = tree._line;
        ret._filename = tree._filename;

        for (var i = 0; i < source.length; i++) {
            var token = source[i];
            if (typeof token == "object") {
              if (token[0] === "unquote" ||
                  token[0] === "quote" ||
                  token[0] === "quasiquote")
                ret = ret.concat(replaceCode(token));
              else
                ret.push(replaceCode(token));
            }
            else if (token === "unquote") {
                token = source[++i];
                if (typeof token === "object") {
                    ret.push(replaceCode(token));
                } else  {
                    var splicing = token[0] === "@";
                    var spreading = token.substr(-3) === "...";
                    token = splicing ? token.substr(1) : token;
                    var repl = replacements[token];
                    if (splicing || spreading)
                        ret = ret.concat(repl);
                    else
                        ret.push(repl);
                }
            }
            else if (token === "quote") {
                token = source[++i];
                ret.push(token);
            }
            else if (token === "quasiquote") {
                token = source[++i];
                ret = ret.concat(replaceCode(token));
            }
            else {
              ret.push(token);
            }
        }
        return ret;
    };
    return replaceCode(code);
};

var handleOperator = function(arr) {
    if (arr.length != 3)  throw handleError(0, arr._line);
    handleSubExpressions(arr);
    if (arr[0] == "=") arr[0] = "===";
    if (arr[0] == "!=") arr[0] = "!==";
    return templates["operator"]({operator: arr[0], loperand: arr[1], roperand: arr[2]});
};

var handleError = function(no, line, filename) {
    return errors[no] + ((line) ? "\nLine no " + line : "") + ((filename) ? "\nFile " + filename : "");
};

var readers = {};

readers[".-"] = function(expression) {
  var invoker = expression[0];
  var target = expression[1];
  var owner = _.isArray(target) ? handleExpression(target)
                                : handleSymbol(target);
  var field = handleSymbol(invoker.substr(2));
  return templates[".field"]({ target: owner, field: field });

};

readers["."] = function(expression) {
  var invoker = expression[0];
  var target = expression[1];
  var params = expression.slice(2);
  var owner = _.isArray(target) ? handleExpression(target)
                                : handleSymbol(target);

  var method = handleExpression([ invoker.substr(1) ].concat(params));
  return templates[".invoke"]({ target: owner, method: method });
};


keywords["js"] = function(arr) {
  return handleSubExpressions(arr.slice(1)).join(' ');
};

keywords["function"] = function(arr) {
    if (arr.length < 3) throw handleError(0, arr._line, arr._filename);
    if (typeof arr[1] != "object") throw handleError(0, arr._line);
    var params = arr[1].map(function(name) {
      return handleSymbol(name, arr);
    });

    return templates["function"]({
        params: params.join(","),
        expressions: handleExpressions(arr.slice(2)),
        indent: " ".repeat(indent)});
};

keywords["try"] = function(arr) {
    if (arr.length < 3) throw handleError(0, arr._line, arr._filename);
    var c = arr.pop();
    return templates["try"]({
        trypart: handleExpressions(arr.slice(1)),
        catchpart: _.isArray(c) ? handleExpression(c) : c,
        indent: " ".repeat(indent)});
};

keywords["symbol"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    return arr[1].substr(1, arr[1].length - 2)
}

keywords["symbols-join"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    return handleSubExpressions(arr.slice(2)).join(arr[1]);
};

keywords["if"] = function(arr) {
    if (arr.length < 3 || arr.length > 4)  throw handleError(0, arr._line, arr._filename);
    indent += 4;
    handleSubExpressions(arr);
    var ret = templates["if"]({
        condition: arr[1],
        trueexpr: arr[2],
        falseexpr: arr[3] || "undefined",
        indent: " ".repeat(indent)});
    indent -= 4;
    return ret;
};

keywords["str"] = function(arr) {
    if (arr.length < 2) throw handleError(0, arr._line, arr._filename);
    handleSubExpressions(arr);
    return templates["str"]({elems: arr.slice(1).join(",")});
};

keywords["macro"] = function(arr) {
    if (arr.length != 4)  throw handleError(0, arr._line, arr._filename);
    macros[arr[1]] = {template: arr[2], code: arr[3]};
    return "";
};

keywords["include"] = function(arr) {
    if (arr.length != 2)  throw handleError(0, arr._line, arr._filename);
    indent -= 4;
    var filename = arr[1];
    if (typeof filename === "string")
        filename = filename.replace(/["']/g, "");

    var module = new Module(arr._filename);
    module.filename = arr._filename;

    try {
        filename = Module._resolveFilename(filename, module);
        require(filename);
    } catch (err) {
        throw handleError(11, arr._line, arr._filename);
    }

    indent += 4;
    return "";
};

keywords["+"] = handleOperator;

keywords["-"] = handleOperator;

keywords["*"] = handleOperator;

keywords["/"] = handleOperator;

keywords["%"] = handleOperator;

keywords["="] = handleOperator;

keywords["!="] = handleOperator;

keywords[">"] = handleOperator;

keywords[">="] = handleOperator;

keywords["<"] = handleOperator;

keywords["<="] = handleOperator;

keywords["||"] = handleOperator;

keywords["&&"] = handleOperator;


keywords["!"] = function(arr) {
    if (arr.length != 2)  throw handleError(0, arr._line, arr._filename);
    handleSubExpressions(arr);
    return "(!" + arr[1] + ")";
};

errors = [];
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid variable name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";
errors[11] = "Cannot Open include File";
errors[12] = "Invalid symbol";

exports._compile = function(code, filename) {
  indent = -4;
  var tree = parse(code, filename);
  return banner + handleExpressions(tree);
};

});
