// Generated by LispyScript v0.2.1
var meta = require("./ast").meta;
var withMeta = require("./ast").withMeta;
var isSymbol = require("./ast").isSymbol;
var symbol = require("./ast").symbol;
var isKeyword = require("./ast").isKeyword;
var keyword = require("./ast").keyword;
var isUnquote = require("./ast").isUnquote;
var unquote = require("./ast").unquote;
var isUnquoteSplicing = require("./ast").isUnquoteSplicing;
var unquoteSplicing = require("./ast").unquoteSplicing;
var isQuote = require("./ast").isQuote;
var quote = require("./ast").quote;
var isSyntaxQuote = require("./ast").isSyntaxQuote;
var syntaxQuote = require("./ast").syntaxQuote;
var name = require("./ast").name;
var gensym = require("./ast").gensym;
var deref = require("./ast").deref;
var set = require("./ast").set;
var isAtom = require("./ast").isAtom;
var isSymbolIdentical = require("./ast").isSymbolIdentical;

var isEmpty = require("./list").isEmpty;
var count = require("./list").count;
var isList = require("./list").isList;
var list = require("./list").list;
var first = require("./list").first;
var second = require("./list").second;
var third = require("./list").third;
var rest = require("./list").rest;
var cons = require("./list").cons;
var reverse = require("./list").reverse;
var mapList = require("./list").mapList;
var concatList = require("./list").concatList;
var reduceList = require("./list").reduceList;
var listToVector = require("./list").listToVector;

var isOdd = require("./runtime").isOdd;
var isDictionary = require("./runtime").isDictionary;
var dictionary = require("./runtime").dictionary;
var merge = require("./runtime").merge;
var mapDictionary = require("./runtime").mapDictionary;

var nil = void 0;

var isSelfEvaluating = function(form) {
  return ((Object.prototype.toString.call(form) === '[object Number]') || ((Object.prototype.toString.call(form) === '[object String]') || ((typeof(form) === "boolean") || ((form == null) || isKeyword(form)))));
};

var __macros__ = {};

var executeMacro = function(name, form) {
  return __macros__[name](form);
};

var installMacro = function(name, macro) {
  return __macros__[name] = macro;
};

var isMacro = function(name) {
  return (isSymbol(name) && (__macros__[name] && true));
};

var makeMacro = function(pattern, body) {
  return (function() {
    var x = gensym();
    var program = compile(macroexpand(cons(symbol("fn"), cons(pattern, body))));
    var macro = eval(''.concat("(", program, ")"));
    return function(form) {
      return macro.apply(macro, listToVector(rest(form)));
    };
  })();
};

installMacro(symbol("defmacro"), function(form) {
  return (function() {
    var signature = rest(form);
    return (function() {
      var name = first(signature);
      var pattern = second(signature);
      var body = rest(rest(signature));
      return installMacro(name, makeMacro(pattern, body));
    })();
  })();
});

var __specials__ = {};

var installSpecial = function(name, f, validator) {
  return __specials__[name] = function(form) {
    validator ?
      validator(form) :
      void 0;
    return f(rest(form));
  };
};

var isSpecial = function(name) {
  return (isSymbol(name) && (__specials__[name] && true));
};

var executeSpecial = function(name, form) {
  return __specials__[name](form);
};

var opt = function(argument, fallback) {
  return ((argument == null) || isEmpty(argument)) ?
    fallback :
    first(argument);
};

var applyForm = function(fnName, form, isQuoted) {
  return cons(fnName, isQuoted ?
    mapList(form, function(e) {
      return list(quote, e);
    }) :
    form, form);
};

var applyUnquotedForm = function(fnName, form) {
  return cons(fnName, mapList(form, function(e) {
    return isUnquote(e) ?
      second(e) :
      (isList(e) && isKeyword(first(e))) ?
        list(syntaxQuote, second(e)) :
        list(syntaxQuote, e);
  }));
};

var splitSplices = function(form, fnName) {
  var makeSplice = function(form) {
    return (isSelfEvaluating(form) || isSymbol(form)) ?
      applyUnquotedForm(fnName, list(form)) :
      applyUnquotedForm(fnName, form);
  };
  return (function loop(nodes, slices, acc) {
    var recur = loop;
    while ((recur === loop)) {
      recur = isEmpty(nodes) ?
        reverse(isEmpty(acc) ?
          slices :
          cons(makeSplice(reverse(acc)), slices)) :
        (function() {
          var node = first(nodes);
          return isUnquoteSplicing(node) ?
            (nodes = rest(nodes),
             slices = cons(second(node), isEmpty(acc) ?
               slices :
               cons(makeSplice(reverse(acc)), slices)),
             acc = list(),
             loop) :
            (nodes = rest(nodes),
             slices = slices,
             acc = cons(node, acc),
             loop);
        })()
    };
    return recur;
  })(form, list(), list());
};

var syntaxQuoteSplit = function(appendName, fnName, form) {
  return (function() {
    var slices = splitSplices(form, fnName);
    return (count(slices) == 1) ?
      first(slices) :
      applyForm(appendName, slices);
  })();
};

var compileObject = function(form) {
  return isKeyword(form) ? (compile(list(symbol("::compile:keyword"), form))) :
  isSymbol(form) ? (compile(list(symbol("::compile:symbol"), form))) :
  (Object.prototype.toString.call(form) === '[object Number]') ? (compile(list(symbol("::compile:number"), form))) :
  (Object.prototype.toString.call(form) === '[object String]') ? (compile(list(symbol("::compile:string"), form))) :
  (typeof(form) === "boolean") ? (compile(list(symbol("::compile:boolean"), form))) :
  (form == null) ? (compile(list(symbol("::compile:nil"), form))) :
  (Object.prototype.toString.call(form) === '[object Array]') ? (compile(applyForm(symbol("vector"), list.apply(list, form)))) :
  isList(form) ? (compile(applyForm(symbol("list"), form))) :
  isDictionary(compile(applyForm(symbol("dictionary"), form)));
};

var compileReference = function(form) {
  var id = name(form);
  id = id.split("*").join("_");
  id = id.split("->").join("-to-");
  id = id.split("!").join("");
  id = id.split("%").join("$");
  id = (id.substr(-1) === "?") ?
    ''.concat("is-", id.substr(0, ((id).length - 1))) :
    id;
  id = id.split("-").reduce(function(result, key) {
    return ''.concat(result, result ?
      ''.concat(key[0].toUpperCase(), key.substr(1)) :
      key);
  }, "");
  return symbol(id);
};

var compileSyntaxQuoted = function(form) {
  return isList(form) ? (compile(syntaxQuoteSplit(symbol("concat-list"), symbol("list"), form))) :
  (Object.prototype.toString.call(form) === '[object Array]') ? (compile(syntaxQuoteSplit(symbol("concat-vector"), symbol("vector"), list.apply(list, form)))) :
  isDictionary(form) ? (compile(syntaxQuoteSplit(symbol("merge"), symbol("dictionary"), form))) :
  "else" ? (compileObject(form)) :
  void 0;
};

var compile = function(form) {
  return isSelfEvaluating(form) ? (compileObject(form)) :
  isSymbol(form) ? (compileReference(form)) :
  (Object.prototype.toString.call(form) === '[object Array]') ? (compileObject(form)) :
  isDictionary(form) ? (compileObject(form)) :
  isList(form) ? ((function() {
    var head = first(form);
    return isQuote(form) ? (compileObject(second(form))) :
    isSyntaxQuote(form) ? (compileSyntaxQuoted(second(form))) :
    isSpecial(head) ? (executeSpecial(head, form)) :
    "else" ? ((function() {
      return !(isSymbol(head) || isList(head)) ?
        (function() {
          throw ''.concat("operator is not a procedure: ", head);
        })() :
        compile(list(symbol("::compile:invoke"), head, rest(form)));
    })()) :
    void 0;
  })()) :
  void 0;
};

var compileProgram = function(forms) {
  return (function loop(result, expressions) {
    var recur = loop;
    while ((recur === loop)) {
      recur = isEmpty(expressions) ?
        result :
        (result = ''.concat(result, isEmpty(result) ?
          "" :
          ";\n\n", compile(macroexpand(first(expressions)))),
         expressions = rest(expressions),
         loop)
    };
    return recur;
  })("", forms);
};

var macroexpand1 = function(form) {
  return isList(form) ?
    (function() {
      var op = first(form);
      var id = name(op);
      return isSpecial(op) ? (form) :
      isMacro(op) ? (executeMacro(op, form)) :
      (isSymbol(op) && !(id === ".")) ? ((id.charAt(0) === ".") ?
        (count(form) < 2) ?
          (function() {
            throw Error("Malformed member expression, expecting (.member target ...)");
          })() :
          cons(symbol("."), cons(second(form), cons(symbol(id.substr(1)), rest(rest(form))))) :
        (id.charAt(((id).length - 1)) === ".") ?
          cons(symbol("new"), cons(symbol(id.substr(0, ((id).length - 1))), rest(form))) :
          form) :
      "else" ? (form) :
      void 0;
    })() :
    form;
};

var macroexpand = function(form) {
  return (function loop(original, expanded) {
    var recur = loop;
    while ((recur === loop)) {
      recur = (original === expanded) ?
        original :
        (original = expanded,
         expanded = macroexpand1(expanded),
         loop)
    };
    return recur;
  })(form, macroexpand1(form));
};

var compileTemplate = function(form) {
  var indentPattern = /\n *$/;
  var lineBreakPatter = RegExp("\n", "g");
  var getIndentation = function(code) {
    return (function() {
      var match = code.match(indentPattern);
      return ((match && match[0]) || "\n");
    })();
  };
  return (function loop(code, parts, values) {
    var recur = loop;
    while ((recur === loop)) {
      recur = ((parts).length > 1) ?
        (code = ''.concat(code, parts[0], ''.concat("", first(values)).replace(lineBreakPatter, getIndentation(parts[0]))),
         parts = parts.slice(1),
         values = rest(values),
         loop) :
        code.concat(parts[0])
    };
    return recur;
  })("", first(form).split("~{}"), rest(form));
};

var compileDef = function(form) {
  return compileTemplate(list("var ~{}", compile(cons(symbol("set!"), form))));
};

var compileIfElse = function(form) {
  return compileTemplate(list("~{} ?\n  ~{} :\n  ~{}", compile(first(form)), compile(second(form)), compile(third(form))));
};

var desugarFnName = function(form) {
  return isSymbol(first(form)) ?
    form :
    cons(nil, form);
};

var desugarFnDoc = function(form) {
  return (Object.prototype.toString.call(second(form)) === '[object String]') ?
    form :
    cons(first(form), cons(nil, rest(form)));
};

var desugarBody = function(form) {
  return isList(third(form)) ?
    form :
    withMeta(cons(first(form), cons(second(form), list(rest(rest(form))))), meta(third(form)));
};

var compileFnParams = function(params) {
  return params.join(", ");
};

var compileDesugaredFn = function(name, doc, params, body) {
  return compileTemplate((name == null) ?
    list("function(~{}) {\n  ~{}\n}", compileFnParams(params), compileFnBody(body)) :
    list("function ~{}(~{}) {\n  ~{}\n}", compile(name), compileFnParams(params), compileFnBody(body)));
};

var compileFnBody = function(form) {
  return (function loop(result, expression, expressions) {
    var recur = loop;
    while ((recur === loop)) {
      recur = isEmpty(expressions) ?
        ''.concat(result, "return ", compile(macroexpand(expression)), ";") :
        (result = ''.concat(result, compile(macroexpand(expression)), ";", "\n"),
         expression = first(expressions),
         expressions = rest(expressions),
         loop)
    };
    return recur;
  })("", first(form), rest(form));
};

var compileFn = function(form) {
  return (function() {
    var signature = desugarFnDoc(desugarFnName(form));
    var name = first(signature);
    var doc = second(signature);
    var params = third(signature);
    var body = rest(rest(rest(signature)));
    return compileDesugaredFn(name, doc, params, body);
  })();
};

var compileFnInvoke = function(form) {
  return compileTemplate(list(isList(first(form)) ?
    "(~{})(~{})" :
    "~{}(~{})", compile(first(form)), compileGroup(second(form))));
};

var compileGroup = function(form) {
  return listToVector(mapList(form, compile)).join(", ");
};

var compileDo = function(form) {
  return compile(list(cons(symbol("fn"), cons(Array(), form))));
};

var defineBindings = function(bindings) {
  return (function loop(defs, bindings) {
    var recur = loop;
    while ((recur === loop)) {
      recur = ((bindings).length == 0) ?
        reverse(defs) :
        (defs = cons(list(symbol("def"), bindings[0], bindings[1]), defs),
         bindings = bindings.slice(2),
         loop)
    };
    return recur;
  })(list(), bindings);
};

var compileLet = function(form) {
  return compile(cons(symbol("do"), concatList(defineBindings(first(form)), rest(form))));
};

var compileThrow = function(form) {
  return compileTemplate(list("(function() { throw ~{}; })()", compile(first(form))));
};

var compileSet = function(form) {
  return compileTemplate(list("~{} = ~{}", compile(first(form)), compile(second(form))));
};

var compileVector = function(form) {
  return compileTemplate(list("[~{}]", compileGroup(form)));
};

var compileTry = function(form) {
  return (function loop(tryExprs, catchExprs, finallyExprs, exprs) {
    var recur = loop;
    while ((recur === loop)) {
      recur = isEmpty(exprs) ?
        isEmpty(catchExprs) ?
          compileTemplate(list("(function() {\ntry {\n  ~{}\n} finally {\n  ~{}\n}})()", compileFnBody(tryExprs), compileFnBody(finallyExprs))) :
          isEmpty(finallyExprs) ?
            compileTemplate(list("(function() {\ntry {\n  ~{}\n} catch (~{}) {\n  ~{}\n}})()", compileFnBody(tryExprs), first(catchExprs), compileFnBody(rest(catchExprs)))) :
            compileTemplate(list("(function() {\ntry {\n  ~{}\n} catch (~{}) {\n  ~{}\n} finally {\n  ~{}\n}})()", compileFnBody(tryExprs), first(catchExprs), compileFnBody(rest(catchExprs)), compileFnBody(finallyExprs))) :
        isSymbolIdentical(first(first(exprs)), symbol("catch")) ?
          (tryExprs = tryExprs,
           catchExprs = rest(first(exprs)),
           finallyExprs = finallyExprs,
           exprs = rest(exprs),
           loop) :
          isSymbolIdentical(first(first(exprs)), symbol("finally")) ?
            (tryExprs = tryExprs,
             catchExprs = catchExprs,
             finallyExprs = rest(first(exprs)),
             exprs = rest(exprs),
             loop) :
            (tryExprs = cons(first(exprs), tryExprs),
             catchExprs = catchExprs,
             finallyExprs = finallyExprs,
             exprs = rest(exprs),
             loop)
    };
    return recur;
  })(list(), list(), list(), reverse(form));
};

var compileMethodInvoke = function(form) {
  return compile(cons(symbol(''.concat(compile(first(form)), ".", compile(second(form)))), rest(rest(form))));
};

var compileApply = function(form) {
  return compile(list(symbol("."), first(form), symbol("apply"), first(form), second(form)));
};

installSpecial(symbol("set!"), compileSet);

installSpecial(symbol("def"), compileDef);

installSpecial(symbol("if"), compileIfElse);

installSpecial(symbol("do"), compileDo);

installSpecial(symbol("fn"), compileFn);

installSpecial(symbol("let"), compileLet);

installSpecial(symbol("throw"), compileThrow);

installSpecial(symbol("vector"), compileVector);

installSpecial(symbol("try"), compileTry);

installSpecial(symbol("."), compileMethodInvoke);

installSpecial(symbol("apply"), compileApply);

installSpecial(symbol("::compile:invoke"), compileFnInvoke);

installSpecial(symbol("::compile:keyword"), function(form) {
  return ''.concat("\"", name(first(form)), "\"");
});

installSpecial(symbol("::compile:reference"), function(form) {
  return name(compileReference(first(form)));
});

installSpecial(symbol("::compile:symbol"), function(form) {
  return compile(list(symbol("symbol"), name(first(form))));
});

installSpecial(symbol("::compile:nil"), function(form) {
  return "void 0";
});

installSpecial(symbol("::compile:number"), function(form) {
  return first(form);
});

installSpecial(symbol("::compile:boolean"), function(form) {
  return (first(form) === true) ?
    "true" :
    "false";
});

installSpecial(symbol("::compile:string"), function(form) {
  string = first(form);
  string = string.replace(RegExp("\\\\", "g"), "\\\\");
  string = string.replace(RegExp("\n", "g"), "\\n");
  string = string.replace(RegExp("\r", "g"), "\\r");
  string = string.replace(RegExp("\t", "g"), "\\t");
  string = string.replace(RegExp("\"", "g"), "\\\"");
  return ''.concat("\"", string, "\"");
});

var installNative = function(name, operator, fallback, validator) {
  return installSpecial(name, function(form) {
    return reduceList(mapList(form, compile), function(left, right) {
      return compileTemplate(list("~{} ~{} ~{}", left, operator, right));
    }, isEmpty(form) ?
      fallback :
      nil);
  }, validator);
};

var compilerError = function(form, message) {
  return (function() {
    var error = Error(''.concat(message));
    error.line = 1;
    return (function() {
      throw error;
    })();
  })();
};

var verifyTwo = function(form) {
  return (isEmpty(rest(form)) || isEmpty(rest(rest(form)))) ?
    (function() {
      throw compilerError(form, ''.concat(first(form), " form requires at least two operands"));
    })() :
    void 0;
};

installNative(symbol("and"), symbol("&&"));

installNative(symbol("or"), symbol("||"));

installNative(symbol("+"), symbol("+"), 0);

installNative(symbol("-"), symbol("-"), 0, verifyTwo);

installNative(symbol("*"), symbol("*"), 1);

installNative(symbol("/"), symbol("/"), 1, verifyTwo);

exports.isSelfEvaluating = isSelfEvaluating;
exports.compile = compile;
exports.compileProgram = compileProgram;
exports.macroexpand = macroexpand;
exports.macroexpand1 = macroexpand1;

